# 6. 정렬

# 1. 선택 정렬 → 최소 값과 swap

가장 작은 요소를 맨 앞으로 이동하는 식으로 정렬을 진행

전체 요소가 n개 있다면, n번 연산을 수행

0번째를 기준으로 1번째~6번째 중 가장 작은 값을 찾아서,

0번째와 가장 작은 값 swap

**→ 각 index를 기준으로 index 이후에 가장 작은 값을 가지는 index의 값과 swap해준다.**

같은 방식으로 5번째(끝까지) 연산을 수행한다. 

(마지막 6번째 자리에는 이미 배열에서 가장 큰 값이 위치해 있을 것이므로)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a9a63407-316e-4335-891b-f902f8f2ef5d/Untitled.png)

# 2. 삽입 정렬 → 왼쪽 값과 계속 비교 후 인덱스 조정

→ **바로 오른쪽 값과 왼쪽 값(여러개 있으면 인덱스0번까지) 을 비교하여 적당한 위치에 삽입한다.**

case1) **왼쪽 값**과 비교했을 때 **해당 인덱스 값**과 같거나 보다 작으면 , 다음으로 넘어감.

case2) **왼쪽 값**과 비교했을 때 **해당 인덱스 값**보다 크다면, **해당 인덱스 값**보다 **작은 값**이 나올 때 까지 **왼쪽 값들의 인덱스를 조정**해준다. 그리고 해당 인덱스 값의 인덱스를 변경

```python
temp =a[j]; // 탐색 값

while(j>0&& a[j-1]>temp){

	a[j]=a[j-1]; // 값을 오른쪽으로 땡겨줌

	j—; // j값 조정
}
a[j] = temp;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c51966e2-16b0-424e-b6e5-be99cc6e0576/Untitled.png)

# 3. 셸 정렬

단순 삽입 정렬의 장점을 살리고, 단점을 보완한 정렬 알고리즘

일정한 간격으로 떨어져 있는 두 요소를 그룹으로 묶어 대략 정렬을 수행하고, 

간격을 좁히면서 정렬을 반복해서 **“요소의 이동 횟수를 줄이는 방법”**