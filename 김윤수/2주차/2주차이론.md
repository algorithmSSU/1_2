# 2ì£¼ì°¨

### ğŸ“šÂ Stack

STLì—ì„œ ì œê³µí•˜ëŠ” í•¨ìˆ˜ empty(), size(), top(),push(), pop(), emplace() ë“±ì˜ í•¨ìˆ˜ë¥¼ ì œê³µ.

íŠ¹ì§• : Last InğŸ“¥, First OutğŸ“¤(LIFO)

ëª¨ë“  í™œë™ì— ì‹œê°„ë³µì¡ë„ $O(n)$

```cpp
/* ë°°ì—´ë¡œ ë§Œë“œëŠ” ìŠ¤íƒ */
#include <iostream>
#include <stdexcept>
template <typename T, int size>
class ArrayStack{
    private:
        T* pArray;
        int top;
    public:
        ArrayStack(){
            pArray = new T[size];
            top = -1;
        }
        ~ArrayStack(){
            delete[] pArray;
            top = -1;
        }

        bool empty(){
            return top == -1;
        }
        void push(T element){
            if(top == size -1){
                throw out_of_range("Stack Overflow!!");
            }
            stack[++top] = element;
        }

        T top(){
            return pArray[top];
        }
        void pop(){
            if(empty())
                throw out_of_range("Stack Overflow!!");
            delete pArray[top];
            top--;
        }
        int size(){
            return top + 1;
        }
}
```

```cpp
/* ì‹±ê¸€ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¡œ ë§Œë“œëŠ” ìŠ¤íƒ */
template <typename T>
class Node{
	T data;
	Node* next;
	Node(){
		next = NULL;
		data = NULL;
	}
	Node(T element, Node* ptr){
		data = element;
		next = ptr->next;
		ptr->next = this;
	}
}

<template typename T> 
class SLLStack{
    private:
        Node<T>* head;
				Node<T>* tail;
    public:
        SLLStack(): head(nullptr), tail(nullptr){
            pArray = new T[size];
            top = -1;
        }
        ~SLLStack(){}

        bool empty(){
            return top == -1;
        }
        void push(T element){
            if(top == size -1){
                throw out_of_range("Stack Overflow!!");
            }
            stack[++top] = element;
        }

        T top(){
						return tail->value;
        }
        void pop(){
            if(empty())
                throw out_of_range("Stack Overflow!!");
						Node<T>*ptr = head;
						T value = head->value;
						if(head == tail){
							head = nullptr;
							tail = nullptr;
							delete(head);
						}
						else{
								while(ptr != nullptr){
									if(ptr->next == tail){
										value = tail->value;
										ptr->next = nullptr;
										delete(tail);
										tail = ptr;
										break;
									}
									ptr = ptr->next;
								}
								return value;
						}
						return value;
        }
        int size(){
					Node<T>*ptr = head;
					int count = 0;
					while(ptr != tail){
						count++;
					}
					return count;
        }
}

```

```cpp
/* ë‘ ê°œì˜ íë¡œ ë§Œë“œëŠ” ìŠ¤íƒ */

#include <bits/stdc++.h>

using namespace std;
template<typename T>
class QQStack{
	private:
		queue<T> q1, q2;
		int curr_size;
	public:
		Stack(){
			curr_size = 0;
		}
		void push(int x){
			curr_size++;
			q2.push(x);
			while(!q1.empty()){
				q2.push(q1.front());
				q1.pop();
			}
			q1.swap(q2);
		}

		void pop(){
			if(q1.empty()) return;
			q1.pop();
			curr_size--;
		}

		T top(){
			if(q1.empty()) return -1;
			return q1.front();
		}

		int size(){
			return curr_size;
		}
}
```

### ğŸ“šÂ Queue

STLì—ì„œ ì œê³µí•˜ëŠ” í•¨ìˆ˜ empty(), size(), front(), push(), front(), back(), size(), enqueue(), dequeue()

```cpp
/* ë°°ì—´ë¡œ ë§Œë“œëŠ” í */
<template typename T>
class QueueArray
{
private:
	int front;				//Dequeue í–ˆì„ë•Œ ë‚˜ì˜¬ Index
	int rear;				//Enqueue í–ˆì„ë•Œ ë“¤ì–´ê°ˆ Index
	int maxSize;				//ë°°ì—´ í¬ê¸°
	T* arrays;				//ë™ì  í• ë‹¹í•  ë°°ì—´
public:
	QueueArray(int size = 10);		//ìƒì„±ì(ë””í´íŠ¸ëŠ” 10)
	~QueueArray();				//ì†Œë©¸ì
	bool Enqueue(int value);		//ê°’ì„ ë„£ëŠ”ë‹¤.
	bool Dequeue(int& value);		//ê°’ì„ ëº€ë‹¤.
};

#include "QueueArray.h"
#include <stdio.h>

QueueArray::QueueArray(int size)
{
	printf("ìƒì„±ì\n");

	maxSize = size + 1;				//size = ë‚´ê°€ ì‚¬ìš©í•  í¬ê¸° / +1 = ë¹„ì–´ìˆëŠ” ê°’ rear
	arrays = new int[maxSize];			//ë°°ì—´ ë™ì  í• ë‹¹
	front = rear = 0;				//frontì™€ rear ì´ ê°™ìœ¼ë©´ ë¹„ì–´ìˆë‹¤.
}

QueueArray::~QueueArray()
{
	delete[] arrays;				//ë°°ì—´ë¡œ ë™ì í• ë‹¹ í–ˆê¸° ë•Œë¬¸ì— delete[]

	printf("ì†Œë©¸ì\n");
}

bool QueueArray::Enqueue(T value)
{
	if ((rear + 1) % maxSize == front)		//íê°€ ê½‰ì°¨ìˆìœ¼ë©´
		return false;

	*(arrays + rear++) = value;			//ê°’ì„ ë„£ì–´ì¤€ë‹¤.
	rear %= maxSize;				//í™˜í˜•ì„ ìœ„í•´ì„œ
	printf("enqueu : %d\t", value);
	printf("front : %d \t rear : %d\n", front,rear);
	return true;
}

bool QueueArray::Dequeue(T& value)
{
	if (front == rear)				//íê°€ ë¹„ì–´ìˆìœ¼ë©´
		return false;

	value = *(arrays + front++);			//ê°’ì„ ë„£ì–´ì¤€ë‹¤.
	front %= maxSize;				//í™˜í˜•ì„ ìœ„í•´ì„œ
	printf("dequeu : %d\t", value);
	printf("front : %d \t rear : %d\n", front, rear);
	return true;
}
```

```cpp
/* ì‹±ê¸€ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¡œ ë§Œë“œëŠ” í */
class QueueLinkedList
{
	struct Node					
	{
		int data;			//ê°’
		Node* prev;			//ì´ì „ ë…¸ë“œ ì •ë³´
		Node* next;			//ë‹¤ìŒ ë…¸ë“œ ì •ë³´
	};

private:
	Node* head;				//ë¨¸ë¦¬ ë”ë¯¸
	Node* tail;				//ê¼¬ë¦¬ ë”ë¯¸

public:
	QueueLinkedList();			//ìƒì„±ì
	~QueueLinkedList();			//ì†Œë©¸ì
	bool Enqueue(int value);		//ê°’ì„ ë„£ëŠ”ë‹¤.
	bool Dequeue(int& value);		//ê°’ì„ ëº€ë‹¤
};

QueueLinkedList::QueueLinkedList()
{
	printf("ìƒì„±ì\n");

	head = new Node();			//ë¨¸ë¦¬ ë…¸ë“œ í• ë‹¹
	tail = new Node();			//ê¼¬ë¦¬ ë…¸ë“œ í• ë‹¹
	head->prev = head;			//ë¨¸ë¦¬ ì´ì „ì€ ë¨¸ë¦¬
	head->next = tail;			//ë¨¸ë¦¬ ë‹¤ìŒì€ ê¼¬ë¦¬
	tail->prev = head;			//ê¼¬ë¦¬ ì´ì „ì€ ë¨¸ë¦¬
	tail->next = tail;			//ê¼¬ë¦¬ ë‹¤ìŒì€ ê¼¬ë¦¬
}

QueueLinkedList::~QueueLinkedList()
{
	Clear();				//ê°’ì„ ëª¨ë‘ ë¹„ì›Œì¤€ë‹¤.
	delete head;				//ë¨¸ë¦¬ ë…¸ë“œ ì‚­ì œ
	delete tail;				//ê¼¬ë¦¬ ë…¸ë“œ ì‚­ì œ

	printf("ì†Œë©¸ì\n");
}

bool QueueLinkedList::Enqueue(int value)
{
	Node* newNode = new Node();		//ìƒì„±ëœ ë…¸ë“œ
	newNode->data = value;			//ìƒì„±ëœ ë…¸ë“œ ê°’ í• ë‹¹
	tail->prev->next = newNode;		//ìƒì„±ëœ ë…¸ë“œ ìœ„ì¹˜ëŠ” ê¼¬ë¦¬ ì´ì „ë…¸ë“œì˜ ë‹¤ìŒ
	newNode->prev = tail->prev;		//ìƒì„±ëœ ë…¸ë“œ ì´ì „ì€ ê¼¬ë¦¬ ì´ì „ë…¸ë“œ
	newNode->next = tail;			//ìƒì„±ëœ ë…¸ë“œì˜ ë‹¤ìŒì€ ê¼¬ë¦¬
	tail->prev = newNode;			//ê¼¬ë¦¬ ì´ì „ì€ ìƒì„±ëœ ë…¸ë“œ

	printf("enqueue : %d\n", newNode->data);
	return true;
}

bool QueueLinkedList::Dequeue(int& value)
{
	if (head->next == tail)			//íê°€ ë¹„ì–´ìˆìœ¼ë©´
		return false;

	Node* deleteNode = head->next;		//ì§€ìš¸ ë…¸ë“œëŠ” ë§¨ ì• ë…¸ë“œ
	value = deleteNode->data;		//ê°’ì„ ë¹¼ë‚¸ë‹¤.

	deleteNode->next->prev = head;		//ì§€ìš¸ ë…¸ë“œ ë‹¤ìŒë…¸ë“œì˜ ì´ì „ì€ ë¨¸ë¦¬ë¥¼ ê°€ë¥´í‚¨ë‹¤.
	head->next = deleteNode->next;		//ë¨¸ë¦¬ ë‹¤ìŒì€ ì§€ìš¸ë…¸ë“œì˜ ë‹¤ìŒì„ ê°€ë¥´í‚¨ë‹¤.
	delete deleteNode;			//ì§€ìš¸ ë…¸ë“œë¥¼ ì§€ìš´ë‹¤.
	printf("dequeue : %d\n", value);

	return true;
}

void QueueLinkedList::Clear()
{
	Node* temp = head->next;		//ì°¾ëŠ” ë…¸ë“œ
	Node* deleteNode;			//ì§€ìš¸ ë…¸ë“œ
	while (temp != tail)			//ë¦¬ìŠ¤íŠ¸ ëê¹Œì§€ ëˆë‹¤.
	{
		deleteNode = temp;		//í˜„ì¬ ë…¸ë“œë¥¼ ì§€ìš¸ ë…¸ë“œë¡œ ì§€ì •í•œë‹¤.
		temp = temp->next;		//í˜„ì¬ ë…¸ë“œëŠ” ë‹¤ìŒ ë…¸ë“œë¡œ ë„˜ì–´ê°„ë‹¤.
		delete deleteNode;		//ì§€ìš¸ ë…¸ë“œë¥¼ ì§€ì›Œì¤€ë‹¤.
	}
	head->next = tail;			//ë‹¤ ë¹„ì—ˆìœ¼ë‹ˆ head ë‹¤ìŒì€ tail
	tail->prev = head;			//tail ì´ì „ì€ head

	printf("clear\n");
}

void QueueLinkedList::PrintAll()
{
	Node* temp = head->next;
	while (temp != tail)
	{
		printf("%d\t", temp->data);
		temp = temp->next;
	}
	printf("\n");
}
```

```cpp
/* ë‘ ê°œì˜ ìŠ¤íƒìœ¼ë¡œ ë§Œë“œëŠ” í */
template <typename T>
class MyQueue {
private:
 stack<T> stack1;
 stack<T> stack2;
 int size = 0;

public:
  void enqueue(T element) {
    stack1.push(element);
    size++;
  }

  T dequeue() {
    if (stack2.empty()) {
      while (!stack1.empty()) {
        stack2.push(stack1.top());
        stack1.pop();
      }
    }

    T temp = NULL;
    if (!stack2.empty()) {
      temp = stack2.top();
      stack2.pop();
      size--;
    }
    return temp;
  }
};

```